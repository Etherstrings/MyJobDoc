# 计算机操作系统

## 操作系统基础

1.GUI和SHELL区别

​	图形化界面(Graphical User Interface, GUI)

​	指令界面

2.CPU

​	寄存器-保存关键变量与临时结果

​	特殊寄存器----程序计数器----指向下一条需要从内存提取指令的地址

​	堆栈指针---指向内存中当前栈顶端

​	程序状态寄存器----PSW---跟踪当前系统状态

​	

​	时间多路复用CPU

3.CPU模式-内核态和用户态

​	PSW中属性控制何种状态

​	内核态--执行任何指令集中指令 并且使用硬件功能

​	用户态--执行部分指令

​	用户调用---系统调用----进入内核态

4.多线程与多核芯片

​	多线程----实际上简单的多线程还是一个线程 并不是并发

5.内存

​	快速 量大 便宜

​	![image-20220802163821242](计算机操作系统.assets/image-20220802163821242.png)

​	寄存器---最顶层

​	CPU一样材料，和CPU一样快

​	高速缓存

​	划为高速缓存行

​	内存---RAM

​	磁盘-硬盘

6.I/O设备

7.总线

![image-20220803170539675](计算机操作系统.assets/image-20220803170539675.png)

8.计算机启动过程

​	主板上 有-BIOS 基本 输入 输出 系统

​	BIOS检查RAM数量，键盘和其他基础设备---查找PCle和CPL总线

​	CMOS启动设备

​	BIOS配置程序进入外部或者硬盘内部启动操作系统

9.文件-树机构

​	Linux上有特殊文件

​	线程--文件之间交互----管道

## 硬件结构

### 	1.CPU怎么执行程序的？

​	   实际上就是按照栈读取的方式执行程序-----读入---判断---执行

###### 		1.1 冯诺依曼模型

​       **运算器、控制器、存储器、输入设备、输出设备**，这 5 个部分也被称为**冯诺依曼模型**

​		运算器、控制器是在中央处理器里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，比如键盘就是输入设备，显示器就是输出设备。

​		存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。

###### 		1.2 程序执行过程

​		 CPU 执行程序的过程如下：

​		读取程序计数器----指令内存地址---CPU通过内存地址找到内存

​		读取指令寄存器---确定类型+参数----分为逻辑运算或者控制单元执行

​		程序计数器自增---指向下一条指令

### 2.内存 硬盘运行速度为什么不同？

###### 		1.存储器的层次结构

​		寄存器

​		CPU Cache-----L1 L2 L3

​		内存

​		硬盘

###### 		2.存储器类比关系

​	![image-20220808144725751](计算机操作系统.assets/image-20220808144725751.png)

​		复习看书

​		大脑--CPU

​		 大脑正在思考---寄存器

​		 大脑 的短期记忆——L1

​		 大脑长期记忆--L2 L3

​		内存

​		硬盘

###### 		3.CPU高速缓存 Cache

​		CPU 的高速缓存，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二级缓存、三级缓存。

​		L1 高速缓存通常分成**指令缓存**和**数据缓存**。

​		L2 高速缓存同样每个 CPU 核心都有

​		L3 高速缓存通常是多个 CPU 核心共用的

###### 		4.内存

​		内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 **DRAM （\*Dynamic Random Access Memory\*，动态随机存取存储器）** 的芯片。

​		只有不断刷新，数据才能被存储起来。

###### 		5.硬盘

​		速度慢

###### 		6.CPU怎么读取Cache中的数据？

​		直接映射为例子

​		根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Cache Line 的地址

​		找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行

​		对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行

​		根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字

​		加速方式：

​		1.**遇到这种遍历数组的情况时，按照内存布局顺序访问，将可以有效的利用 CPU Cache 带来的好处，这样我们代码的性能就会得到很大的提升**

​		2.绑定CPU某个核心，不再度加载L1 L2缓存

### 3.CPU缓存一致性

###### 		1.那在什么时机才把 Cache 中的数据写回到内存呢

- 写直达（*Write Through*）

- 写回（*Write Back*）

  保持内存与 Cache 一致性最简单的方式是，**把数据同时写入内存和 Cache 中**，这种方法称为**写直达（\*Write Through\*）**。

  **当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中**

###### 		2.缓存一致性问题

​		由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的**缓存一致性（\*Cache Coherence\*）** 的问题

​		和数据库中的幻读一个意思实际上。



​		怎么解决？

​		某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为**写传播（\*Write Propagation\*）**----数据一致

​		某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为**事务的串行化（\*Transaction Serialization\*）**-----数据可以复现

​		

###### 		3.实现数据的传播-----总线嗅探

​		老方法---总线嗅探

​		变量i变化---发广播---所有cpu自检--有一致

###### 		4.MESI协议

​		MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：

- *Modified*，已修改
- *Exclusive*，独占
- *Shared*，共享
- *Invalidated*，已失效

### 4.CPU如何执行任务？

###### 		1.CPU伪分享问题

​		这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为**伪共享（\*False Sharing\*）**

###### 		2.解决方式

​		对于多个线程共享的热点数据，即经常会修改的数据，应该避免这些数据刚好在同一个 Cache Line 中，否则就会出现为伪共享的问题

​		空间换时间

###### 		3.CPU怎么选择线程的？

​		CFS完全公平调度---为每个任务安排一个虚拟运行时间 vruntime



### 5.什么是软中断？

###### 	1.中断的上下部分

​	中断处理程序的上部分和下半部可以理解为：

- **上半部直接处理硬件请求，也就是硬中断**，主要是负责耗时短的工作，特点是快速执行；
- **下半部是由内核触发，也就说软中断**，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；

​	硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行

###### 	2.如何定位软中断 CPU 使用率过高的问题？

​	抓包解决

### 6.0.1+0.2==0.3？

###### 	1.为什么负数要用补码表示？

​	负数不是使用补码的方式表示，则在做基本对加减法运算的时候，**还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法**

​	**用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的**。

###### 	2.十进制小数与二进制的转换

​	**没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况**

###### 	3.计算机是怎么存小数的？

​	计算机存储小数的采用的是**浮点数**，名字里的「浮点」表示小数点是可以浮动的。

​	计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：

- 符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；
- 指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；
- 尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；

用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。

###### 	4.0.1 + 0.2 == 0.3 吗？

​	不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数



