##### Project 1:漏洞整理排查

​	1.学习了筛查Maven依赖版本

​	2.学习了项目的Maven依赖架构

##### Project2:Excel批量导入用户信息

​	1.EasyExcel---阿里巴巴开源

​		Excel实体类写法

​		监听器写法

​		控制器方法写法

​	2.复习C S SI D各层写法

##### Project3:岗位管理的开发

​	1.熟悉Git的应用---熟悉GitLab 公司开发

​	2.理解模块打包---Maven引入

​	3.JPA多表联查应用

​		Spring Data JPA

​	4.SQl复杂多表查询

​		子查询OR左联

​	5.配置文件应用

​		主Yml

​		可选YML

​	6.Redis应用--可视化软件应用

​	7.Postman+swagger应用接口测试

​		Session的应用

​		Google浏览器开发者模式应用

​	8.注解的应用

​		Dao层注解

​		Service层

​		Controller层

​	9.缓存注解

​		对缓存的理解---存缓存  清理缓存---条件应用

​	10.AOP的具体应用

​		切入点

​		After()

​	11.分辨类

##### 1.JPA语法

##### 2.JPA注解

##### 3.项目无法启动的解决方式

##### 4.yml文件配置功能

##### 5.JPA多表联查

​	JpaUser类里设置：

​	@ManyToOne

​	@JoinColumn(name = "role_id")

​	private JPARole role;



​	JpaRole类里设置：

​	一对多关系

​	@JsonBackReference----生成jason时忽略

​	@OneToMany(targetEntity = JpaUser.class,mappedBy = "role" , cascade = {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH}, fetch = FetchType.LAZY))

​	private List<JpaUser> jpaUsers;



​	一对一关系

```java
    @OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH})
    @JoinColumn(name = "permission_id")
    private JpaPermission permission;
```

##### 6.AOP复习

​	切入点  切入点语法

​	After

##### 7.SpringBoot 缓存

​	@Cache注解

​	@Cacheable @CacheEvit

​	注解条件

##### 8.PostMan

​	接口测试

##### 9.Session用处

##### 10.多表联查语法

​	left join on

##### 11.Redis

​	1.SpringBoot中选用何种缓存存储方式

​		配置端口+节点+数据库段号

​	2.Redis缓存配置类

​		配置缓存类有哪些

##### 12.Logger

​		Logger注册类

##### 13.n的拆分

```Java
public int trans(int n){
    int res=0;
	while(n>0){
        //取个位余数
        int temp=n%10;
        res+=temp;
        //将个位数字去掉
        n=n/10;
    }
    return res;
}	

```

##### 14.Oauth2.0

​		1.Server Clinet Resource三个角色作用

​		

​		2.Server端怎么开发



​		3.Client怎么接入



​		4.Resource怎么转换Token



​		5.单点登录统一认证时序流程图



​		6.Spring Security框架和Oauth2相关的拦截器有什么？



##### 15.Docker

###### 	1.**Docker为什么会出现**

​	Docker 将应用程序与该程序的依赖，打包在一个文件里面，该文件包括了所有打包得应用程序的所有依赖，像数据库等；直接运行改文件，就可以让程序跑起来，从而不用再去考虑环境问题

###### 	2.Docker的用途

（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。

（2）提供弹性的云服务。因为 Docker 容器可以随开随关，很适合动态扩容和缩容。

（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。

###### 	3.Image文件

​	**别人的程序打包在image里面，自己直接拿过来后不用配置环境就可以直接跑**

###### 	4.Docker的安装

​	前提：1.**Docker需要Linux内核的支持**2.**Mware虚拟机**安装Linux系统

​	（1）设置仓库

```
//卸载旧版本
$ sudo apt-get remove docker docker-engine docker.io containerd runc

//更新 apt 包索引
$ sudo apt-get update

//安装 apt 依赖包，用于通过HTTPS来获取仓库
$ sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
    
//添加 Docker 的官方 GPG 密钥
$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -s

//9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。
$ sudo apt-key fingerprint 0EBFCD88

//设置稳定版仓库
$ sudo add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable"
```

​	(2)安装 Docker Engine-Community

```
//更新 apt 包索引
$ sudo apt-get update

//安装最新版本的 Docker Engine-Community 和 containerd
$ sudo apt-get install docker-ce docker-ce-cli containerd.io
```

​	(3)验证安装成功

```
//输入命令
docker
```

###### 5.Docker的启动与停止

​	

```
//（1）启动docker
sudo service docker start
//（2）停止docker
sudo service docker stop
//(3)重启docker
sudo service docker restart
```

###### 6.Docker配置

​	(1)用户加入用户组

```
Docker 需要用户具有 sudo 权限，为了避免每次命令都输入sudo，建议将用户加入Docker用户组

1.添加docker用户组
sudo groupadd docker
2.将当前用户加入到docker用户组
sudo gpasswd -a ${USER} docker
3.重启docker服务
sudo service docker restart
4.退出当前用户重登一下

```

​	（2）配置daemon.json

​	

```
1.进入root权限
su root

2.进入docker文件
查看改文件下只有一个key.json,新建一个daemon.json文件
查看文件夹命令：ls
新建文件夹命令：vim daemon.json

3.编辑docker.json文件
输入以下内容：
{ "registry-mirrors":["https://docker.mirrors.ustc.edu.cn"] }

4.保存退出，重启docker服务
```



###### 	7.Hello-world实例

​		1.命令行直接输入

```
命令：docker image pull library/hello-world

命令解析：
	docker image pull:抓取 image 文件
	library:image 文件所在的组
	hello-world:image 文件的名字
	注意：后期需要的image文件都可以通过这样的方式拉取，像mysql数据库，ubuntu系统等
```

​		2.其中Docker 官方提供的 image 文件，都默认放在library组里面，因此，上面的命令可以写成下面这样。

```
docker image pull hello-world
```

​		3.运行该实例

```
命令：docker container run hello-world

命令解析：
	docker container run:自动抓取 image 文件
	注意：如果发现本地没有指定的 image 文件，就会从仓库自动抓取
```

​		4.对于那些不会自动终止的容器，必须使用docker container kill 命令手动终止。

```
$ docker container kill [containID]
```

###### 		8.容器文件

​		image 文件生成的容器实例，本身也是一个文件，称为容器文件。

​		一旦容器生成，就会同时存在两个文件： image 文件和容器文件。

​		关闭容器并不会删除容器文件，只是容器停止运行而已。

```
# 列出本机正在运行的容器
$ docker container ls

# 列出本机所有容器，包括终止运行的容器
$ docker container ls --all
```

​		上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的docker container kill命令。

​		终止运行的容器文件，依然会占据硬盘空间，可以使用docker container rm命令删除。

```
$ docker container rm [containerID]
```

###### 9.Docker安装mysql

```
//安装mysql
docker pull mysql:5.7
    
//查看拉取的docker镜像
docker ps
​
//docker 启动mysql   容器文件挂载与端口映射
docker run -p 3306:3306 --name mysql \
-v /mydata/mysql/log:/var/log/mysql \
-v /mydata/mysql/data:/var/lib/mysql \
-v /mydata/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7
    
//查看运行的docker容器
docker images
​
//进入mysql容器内部
docker exec -it mysql /bin/bash
​
//获取目录结构 发现mysql就是一个完整的linux目录结构
ls /

```

###### 10.修改mysql配置

```
//进入linux中挂载的mysql配置文件
cd mydata/mysql/conf
//创建mysql配置
vi my.cnf
//随意敲一个英文字母开始编辑 复制粘贴以下内容 esc ":wq" 退出
[client]
default-character-set=utf-8
​
[mysql]
default-character-set=utf-8
​
[mysqld]
init_connect='SET collation_connection=utf8_unicode_ci'
init_connect='SET NAMES utf8'
character-set-server=utf8
collation-server=utf8_unicode_ci
skip-character-set-client-handshake
skip-name-resolve
//修改配置之后一定要记得重启
docker restart mysql
```

###### 11.Docker安装redis+redis持久化

```

//拉取redis镜像
docker pull redis
​
//创建挂载的目录 
mkdir -p /mydata/redis/conf
touch /mydata/redis/conf/redis.conf
​
//启动
docker run -p 6379:6379 --name redis \
-v /mydata/redis/data:/data \
-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf
```

​	这里挂载第三行的redis.conf是一个conf文件，但是直接挂载会被系统认为是一个文件夹而之间创建，所以需要我们先创建这个conf文件。

​	

```
//修改刚创建的redis.conf
vi redis.conf
//修改内容
appendonly yes
//重启redis
docker restart redis
//测试
[root@iZ2ze30iuo2wom5i3mm5qlZ conf]# docker exec -it redis redis-cli
127.0.0.1:6379> set kaigu keai
OK
127.0.0.1:6379> exit
[root@iZ2ze30iuo2wom5i3mm5qlZ conf]# docker restart redis
redis
[root@iZ2ze30iuo2wom5i3mm5qlZ conf]# docker exec -it redis redis-cli
127.0.0.1:6379> get kaigu
"keai"
```



##### 16.谷粒商城

